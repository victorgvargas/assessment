{"ast":null,"code":"import { NUMBERS_STRINGS, SUFFIXES } from \"../constants\";\n\nconst noop = () => {};\n\nconst pushItem = (array, item) => array.push(item);\n\nfunction divide(stringifiedNumber, finalNumber) {\n  const blocksOfHundreds = stringifiedNumber.match(/.{1,3}/g);\n  const blocksOfHundredsCopy = [...blocksOfHundreds];\n\n  for (const [index, block] of blocksOfHundreds.entries()) {\n    finalNumber.push(NUMBERS_STRINGS[parseInt(block[0])] + \" \");\n    finalNumber.push(SUFFIXES.HUNDRED + \" \");\n    convert(block, 1, finalNumber);\n    addSuffixPerBlock(index, {\n      blocksOfHundreds,\n      blocksOfHundredsCopy\n    }, finalNumber);\n  }\n\n  return finalNumber;\n}\n\nfunction convert(block, index, finalNumber) {\n  if (parseInt(block[index]) !== 0) {\n    const dicker = block[index] + block[index + 1];\n\n    if (NUMBERS_STRINGS.hasOwnProperty(parseInt(dicker))) {\n      return pushItem(finalNumber, NUMBERS_STRINGS[parseInt(dicker)]);\n    } else {\n      const dickerPrefix = block[index] + \"0\";\n      return pushItem(finalNumber, `${NUMBERS_STRINGS[dickerPrefix]}-${NUMBERS_STRINGS[parseInt(block[index + 1])]}`);\n    }\n  }\n}\n\nfunction addSuffix(stringArray, finalNumber, operation) {\n  switch (stringArray.length) {\n    case 2:\n      operation === \"push\" ? finalNumber.push(` ${SUFFIXES.THOUSAND} `) : finalNumber.unshift(` ${SUFFIXES.THOUSAND} `);\n      break;\n\n    case 3:\n      operation === \"push\" ? finalNumber.push(` ${SUFFIXES.MILLION} `) : finalNumber.unshift(` ${SUFFIXES.MILLION} `);\n      break;\n\n    case 4:\n      operation === \"push\" ? finalNumber.push(` ${SUFFIXES.BILLION} `) : finalNumber.unshift(` ${SUFFIXES.BILLION} `);\n      break;\n\n    case 5:\n      operation === \"push\" ? finalNumber.push(` ${SUFFIXES.TRILLION} `) : finalNumber.unshift(` ${SUFFIXES.TRILLION} `);\n      break;\n\n    default:\n      noop();\n  }\n\n  return finalNumber;\n}\n\nfunction addFirstSuffix(arrays, finalNumber) {\n  if (arrays.prefixArray.length === 1) {\n    addSuffix(arrays.array, finalNumber, \"unshift\");\n    finalNumber.unshift(NUMBERS_STRINGS[arrays.prefixArray[0]]);\n  }\n\n  return finalNumber;\n}\n\nfunction addSuffixPerBlock(index, blocks, finalNumber) {\n  if (index !== blocks.blocksOfHundreds.length - 1) {\n    addSuffix(blocks.blocksOfHundreds, finalNumber, \"push\");\n    blocks.blocksOfHundredsCopy.pop();\n  }\n\n  return {\n    blocks,\n    finalNumber\n  };\n}\n\nfunction addConnective(index, blocksOfHundreds, finalNumber) {\n  if (index === blocksOfHundreds.length - 2) {\n    finalNumber.push(\" and \");\n  }\n}\n\nfunction normalize(stringifiedNumber, finalNumber) {\n  let stringifiedNumberArray = Array.from(stringifiedNumber);\n  let stringifiedNumberArraySlice = stringifiedNumberArray.slice(0, stringifiedNumber.length % 3);\n  stringifiedNumberArray.splice(0, stringifiedNumberArraySlice.length);\n  stringifiedNumberArray = divide(stringifiedNumberArray.join(\"\"), finalNumber);\n  addFirstSuffix({\n    prefixArray: stringifiedNumberArraySlice,\n    array: stringifiedNumberArray\n  }, finalNumber);\n  return finalNumber;\n}\n\nexport default function useConvert(number) {\n  if (number) {\n    if (NUMBERS_STRINGS.hasOwnProperty(number)) {\n      return NUMBERS_STRINGS[number];\n    }\n\n    const stringifiedNumber = number.toString();\n    let finalNumber = [];\n\n    if (stringifiedNumber.length % 3 === 0) {\n      divide(stringifiedNumber, finalNumber);\n    } else if (stringifiedNumber.length < 3) {\n      convert(stringifiedNumber, 0, finalNumber);\n    } else {\n      normalize(stringifiedNumber, finalNumber);\n    }\n\n    return finalNumber;\n  }\n}","map":{"version":3,"sources":["/home/victor/Documents/React/assessment/js-numerals/src/hooks/useConvert.js"],"names":["NUMBERS_STRINGS","SUFFIXES","noop","pushItem","array","item","push","divide","stringifiedNumber","finalNumber","blocksOfHundreds","match","blocksOfHundredsCopy","index","block","entries","parseInt","HUNDRED","convert","addSuffixPerBlock","dicker","hasOwnProperty","dickerPrefix","addSuffix","stringArray","operation","length","THOUSAND","unshift","MILLION","BILLION","TRILLION","addFirstSuffix","arrays","prefixArray","blocks","pop","addConnective","normalize","stringifiedNumberArray","Array","from","stringifiedNumberArraySlice","slice","splice","join","useConvert","number","toString"],"mappings":"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","sourcesContent":["import { NUMBERS_STRINGS, SUFFIXES } from \"../constants\";\n\nconst noop = () => {};\n\nconst pushItem = (array, item) => array.push(item);\n\nfunction divide(stringifiedNumber, finalNumber) {\n  const blocksOfHundreds = stringifiedNumber.match(/.{1,3}/g);\n  const blocksOfHundredsCopy = [...blocksOfHundreds];\n\n  for (const [index, block] of blocksOfHundreds.entries()) {\n    finalNumber.push(NUMBERS_STRINGS[parseInt(block[0])] + \" \");\n    finalNumber.push(SUFFIXES.HUNDRED + \" \");\n\n    convert(block, 1, finalNumber);\n    addSuffixPerBlock(\n      index,\n      { blocksOfHundreds, blocksOfHundredsCopy },\n      finalNumber\n    );\n  }\n\n  return finalNumber;\n}\n\nfunction convert(block, index, finalNumber) {\n  if (parseInt(block[index]) !== 0) {\n    const dicker = block[index] + block[index + 1];\n    if (NUMBERS_STRINGS.hasOwnProperty(parseInt(dicker))) {\n      return pushItem(finalNumber, NUMBERS_STRINGS[parseInt(dicker)]);\n    } else {\n      const dickerPrefix = block[index] + \"0\";\n      return pushItem(\n        finalNumber,\n        `${NUMBERS_STRINGS[dickerPrefix]}-${\n          NUMBERS_STRINGS[parseInt(block[index + 1])]\n        }`\n      );\n    }\n  }\n}\n\nfunction addSuffix(stringArray, finalNumber, operation) {\n  switch (stringArray.length) {\n    case 2:\n      operation === \"push\"\n        ? finalNumber.push(` ${SUFFIXES.THOUSAND} `)\n        : finalNumber.unshift(` ${SUFFIXES.THOUSAND} `);\n      break;\n    case 3:\n      operation === \"push\"\n        ? finalNumber.push(` ${SUFFIXES.MILLION} `)\n        : finalNumber.unshift(` ${SUFFIXES.MILLION} `);\n      break;\n    case 4:\n      operation === \"push\"\n        ? finalNumber.push(` ${SUFFIXES.BILLION} `)\n        : finalNumber.unshift(` ${SUFFIXES.BILLION} `);\n      break;\n    case 5:\n      operation === \"push\"\n        ? finalNumber.push(` ${SUFFIXES.TRILLION} `)\n        : finalNumber.unshift(` ${SUFFIXES.TRILLION} `);\n      break;\n    default:\n      noop();\n  }\n\n  return finalNumber;\n}\n\nfunction addFirstSuffix(arrays, finalNumber) {\n  if (arrays.prefixArray.length === 1) {\n    addSuffix(arrays.array, finalNumber, \"unshift\");\n    finalNumber.unshift(NUMBERS_STRINGS[arrays.prefixArray[0]]);\n  }\n\n  return finalNumber;\n}\n\nfunction addSuffixPerBlock(index, blocks, finalNumber) {\n  if (index !== blocks.blocksOfHundreds.length - 1) {\n    addSuffix(blocks.blocksOfHundreds, finalNumber, \"push\");\n    blocks.blocksOfHundredsCopy.pop();\n  }\n\n  return { blocks, finalNumber };\n}\n\nfunction addConnective(index, blocksOfHundreds, finalNumber) {\n  if (index === blocksOfHundreds.length - 2) {\n    finalNumber.push(\" and \");\n  }\n}\n\nfunction normalize(stringifiedNumber, finalNumber) {\n  let stringifiedNumberArray = Array.from(stringifiedNumber);\n  let stringifiedNumberArraySlice = stringifiedNumberArray.slice(\n    0,\n    stringifiedNumber.length % 3\n  );\n\n  stringifiedNumberArray.splice(0, stringifiedNumberArraySlice.length);\n  stringifiedNumberArray = divide(stringifiedNumberArray.join(\"\"), finalNumber);\n  addFirstSuffix(\n    { prefixArray: stringifiedNumberArraySlice, array: stringifiedNumberArray },\n    finalNumber\n  );\n\n  return finalNumber;\n}\n\nexport default function useConvert(number) {\n  if (number) {\n    if (NUMBERS_STRINGS.hasOwnProperty(number)) {\n      return NUMBERS_STRINGS[number];\n    }\n\n    const stringifiedNumber = number.toString();\n    let finalNumber = [];\n\n    if (stringifiedNumber.length % 3 === 0) {\n      divide(stringifiedNumber, finalNumber);\n    } else if (stringifiedNumber.length < 3) {\n      convert(stringifiedNumber, 0, finalNumber);\n    } else {\n      normalize(stringifiedNumber, finalNumber);\n    }\n\n    return finalNumber;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}