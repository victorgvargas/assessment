{"ast":null,"code":"import { NUMBERS_STRINGS, SUFFIXES } from \"../constants\";\n\nconst noop = () => {};\n\nconst pushItem = (array, item) => array.push(item);\n\nfunction divide(stringifiedNumber, finalNumber) {\n  const blocksOfHundreds = stringifiedNumber.match(/.{1,3}/g);\n  const blocksOfHundredsCopy = [...blocksOfHundreds];\n\n  for (const [index, block] of blocksOfHundreds.entries()) {\n    finalNumber.push(NUMBERS_STRINGS[parseInt(block[0])] + \" \");\n    finalNumber.push(SUFFIXES.HUNDRED + \" \");\n    convert(block, finalNumber, \"push\");\n    addSuffixPerBlock(index, {\n      blocksOfHundreds,\n      blocksOfHundredsCopy\n    }, finalNumber);\n  }\n\n  return finalNumber;\n}\n\nfunction convert(block, finalNumber, operation) {\n  if (parseInt(block[1]) !== 0) {\n    const dicker = block[1] + block[2];\n\n    if (NUMBERS_STRINGS.hasOwnProperty(parseInt(dicker))) {\n      return pushItem(finalNumber, NUMBERS_STRINGS[parseInt(dicker)]);\n    } else {\n      const dickerPrefix = block[1] + \"0\";\n      return pushItem(finalNumber, `${NUMBERS_STRINGS[dickerPrefix]} ${NUMBERS_STRINGS[parseInt(block[2])]}`);\n    }\n  }\n}\n\nfunction addSuffix(stringArray, finalNumber, operation) {\n  switch (stringArray.length) {\n    case 2:\n      operation === \"push\" ? finalNumber.push(` ${SUFFIXES.THOUSAND} `) : finalNumber.unshift(` ${SUFFIXES.THOUSAND} `);\n      break;\n\n    case 3:\n      operation === \"push\" ? finalNumber.push(` ${SUFFIXES.MILLION} `) : finalNumber.unshift(` ${SUFFIXES.MILLION} `);\n      break;\n\n    case 4:\n      operation === \"push\" ? finalNumber.push(` ${SUFFIXES.BILLION} `) : finalNumber.unshift(` ${SUFFIXES.BILLION} `);\n      break;\n\n    case 5:\n      operation === \"push\" ? finalNumber.push(` ${SUFFIXES.TRILLION} `) : finalNumber.unshift(` ${SUFFIXES.TRILLION} `);\n      break;\n\n    default:\n      noop();\n  }\n\n  return finalNumber;\n}\n\nfunction addFirstSuffix(arrays, finalNumber) {\n  if (arrays.prefixArray.length === 1) {\n    return () => {\n      addSuffix(arrays.array, finalNumber, \"unshift\");\n      finalNumber.unshift(NUMBERS_STRINGS[arrays.prefixArray[0]]);\n    };\n  }\n}\n\nfunction addSuffixPerBlock(index, blocks, finalNumber) {\n  if (index !== blocks.blocksOfHundreds.length - 1) {\n    addSuffix(blocks.blocksOfHundreds, finalNumber);\n    blocks.blocksOfHundredsCopy.pop();\n    return {\n      blocks,\n      finalNumber\n    };\n  }\n}\n\nfunction normalize(stringifiedNumber, finalNumber) {\n  let stringifiedNumberArray = Array.from(stringifiedNumber);\n  let stringifiedNumberArraySlice = stringifiedNumberArray.slice(0, stringifiedNumber.length % 3);\n  stringifiedNumberArray.splice(0, stringifiedNumberArraySlice.length);\n  stringifiedNumberArray = divide(stringifiedNumberArray.join(\"\"), finalNumber);\n  addFirstSuffix({\n    prefixArray: stringifiedNumberArraySlice,\n    array: stringifiedNumberArray\n  }, finalNumber);\n  return finalNumber;\n}\n\nexport default function useConvert(number) {\n  if (number) {\n    if (NUMBERS_STRINGS.hasOwnProperty(number)) {\n      return NUMBERS_STRINGS[number];\n    }\n\n    const stringifiedNumber = number.toString();\n    let finalNumber = [];\n\n    if (stringifiedNumber.length % 3 === 0) {\n      divide(stringifiedNumber, finalNumber);\n    } else {\n      //TODO: IMPLEMENT CONVERTING FOR NON 3 MULTIPLE STRINGS\n      normalize(stringifiedNumber, finalNumber);\n    }\n\n    return finalNumber;\n  }\n}","map":{"version":3,"sources":["/home/victor/Documents/React/assessment/js-numerals/src/hooks/useConvert.js"],"names":["NUMBERS_STRINGS","SUFFIXES","noop","pushItem","array","item","push","divide","stringifiedNumber","finalNumber","blocksOfHundreds","match","blocksOfHundredsCopy","index","block","entries","parseInt","HUNDRED","convert","addSuffixPerBlock","operation","dicker","hasOwnProperty","dickerPrefix","addSuffix","stringArray","length","THOUSAND","unshift","MILLION","BILLION","TRILLION","addFirstSuffix","arrays","prefixArray","blocks","pop","normalize","stringifiedNumberArray","Array","from","stringifiedNumberArraySlice","slice","splice","join","useConvert","number","toString"],"mappings":"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","sourcesContent":["import { NUMBERS_STRINGS, SUFFIXES } from \"../constants\";\n\nconst noop = () => {};\n\nconst pushItem = (array, item) => array.push(item);\n\nfunction divide(stringifiedNumber, finalNumber) {\n  const blocksOfHundreds = stringifiedNumber.match(/.{1,3}/g);\n  const blocksOfHundredsCopy = [...blocksOfHundreds];\n\n  for (const [index, block] of blocksOfHundreds.entries()) {\n    finalNumber.push(NUMBERS_STRINGS[parseInt(block[0])] + \" \");\n    finalNumber.push(SUFFIXES.HUNDRED + \" \");\n\n    convert(block, finalNumber, \"push\");\n    addSuffixPerBlock(\n      index,\n      { blocksOfHundreds, blocksOfHundredsCopy },\n      finalNumber\n    );\n  }\n\n  return finalNumber;\n}\n\nfunction convert(block, finalNumber, operation) {\n  if (parseInt(block[1]) !== 0) {\n    const dicker = block[1] + block[2];\n    if (NUMBERS_STRINGS.hasOwnProperty(parseInt(dicker))) {\n      return pushItem(finalNumber, NUMBERS_STRINGS[parseInt(dicker)]);\n    } else {\n      const dickerPrefix = block[1] + \"0\";\n      return pushItem(\n        finalNumber,\n        `${NUMBERS_STRINGS[dickerPrefix]} ${\n          NUMBERS_STRINGS[parseInt(block[2])]\n        }`\n      );\n    }\n  }\n}\n\nfunction addSuffix(stringArray, finalNumber, operation) {\n  switch (stringArray.length) {\n    case 2:\n      operation === \"push\"\n        ? finalNumber.push(` ${SUFFIXES.THOUSAND} `)\n        : finalNumber.unshift(` ${SUFFIXES.THOUSAND} `);\n      break;\n    case 3:\n      operation === \"push\"\n        ? finalNumber.push(` ${SUFFIXES.MILLION} `)\n        : finalNumber.unshift(` ${SUFFIXES.MILLION} `);\n      break;\n    case 4:\n      operation === \"push\"\n        ? finalNumber.push(` ${SUFFIXES.BILLION} `)\n        : finalNumber.unshift(` ${SUFFIXES.BILLION} `);\n      break;\n    case 5:\n      operation === \"push\"\n        ? finalNumber.push(` ${SUFFIXES.TRILLION} `)\n        : finalNumber.unshift(` ${SUFFIXES.TRILLION} `);\n      break;\n    default:\n      noop();\n  }\n\n  return finalNumber;\n}\n\nfunction addFirstSuffix(arrays, finalNumber) {\n  if (arrays.prefixArray.length === 1) {\n    return () => {\n      addSuffix(arrays.array, finalNumber, \"unshift\");\n      finalNumber.unshift(NUMBERS_STRINGS[arrays.prefixArray[0]]);\n    };\n  }\n}\n\nfunction addSuffixPerBlock(index, blocks, finalNumber) {\n  if (index !== blocks.blocksOfHundreds.length - 1) {\n    addSuffix(blocks.blocksOfHundreds, finalNumber);\n    blocks.blocksOfHundredsCopy.pop();\n\n    return { blocks, finalNumber };\n  }\n}\n\nfunction normalize(stringifiedNumber, finalNumber) {\n  let stringifiedNumberArray = Array.from(stringifiedNumber);\n  let stringifiedNumberArraySlice = stringifiedNumberArray.slice(\n    0,\n    stringifiedNumber.length % 3\n  );\n\n  stringifiedNumberArray.splice(0, stringifiedNumberArraySlice.length);\n  stringifiedNumberArray = divide(stringifiedNumberArray.join(\"\"), finalNumber);\n  addFirstSuffix(\n    { prefixArray: stringifiedNumberArraySlice, array: stringifiedNumberArray },\n    finalNumber\n  );\n\n  return finalNumber;\n}\n\nexport default function useConvert(number) {\n  if (number) {\n    if (NUMBERS_STRINGS.hasOwnProperty(number)) {\n      return NUMBERS_STRINGS[number];\n    }\n\n    const stringifiedNumber = number.toString();\n    let finalNumber = [];\n\n    if (stringifiedNumber.length % 3 === 0) {\n      divide(stringifiedNumber, finalNumber);\n    } else {\n      //TODO: IMPLEMENT CONVERTING FOR NON 3 MULTIPLE STRINGS\n      normalize(stringifiedNumber, finalNumber);\n    }\n\n    return finalNumber;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}