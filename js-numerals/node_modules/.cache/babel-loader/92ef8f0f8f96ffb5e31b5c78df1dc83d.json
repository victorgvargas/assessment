{"ast":null,"code":"import { NUMBERS_STRINGS, SUFFIXES } from \"../constants\";\n\nconst noop = () => {};\n\nconst pushItem = (array, item) => array.push(item);\n\nfunction divide(stringifiedNumber, finalNumber) {\n  const blocksOfHundreds = stringifiedNumber.match(/.{1,3}/g);\n  const blocksOfHundredsCopy = [...blocksOfHundreds];\n\n  for (const [index, block] of blocksOfHundreds.entries()) {\n    finalNumber.push(NUMBERS_STRINGS[parseInt(block[0])] + \" \");\n    finalNumber.push(SUFFIXES.HUNDRED + \" \");\n    convert(block, finalNumber, \"push\");\n    addSuffixPerBlock(index, {\n      blocksOfHundreds,\n      blocksOfHundredsCopy\n    }, finalNumber);\n    addConnective(index, blocksOfHundreds, finalNumber);\n  }\n\n  return finalNumber;\n}\n\nfunction convert(block, finalNumber) {\n  if (parseInt(block[1]) !== 0) {\n    const dicker = block[1] + block[2];\n\n    if (NUMBERS_STRINGS.hasOwnProperty(parseInt(dicker))) {\n      return pushItem(finalNumber, NUMBERS_STRINGS[parseInt(dicker)]);\n    } else {\n      const dickerPrefix = block[1] + \"0\";\n      return pushItem(finalNumber, `${NUMBERS_STRINGS[dickerPrefix]} ${NUMBERS_STRINGS[parseInt(block[2])]}`);\n    }\n  }\n}\n\nfunction addSuffix(stringArray, finalNumber, operation) {\n  switch (stringArray.length) {\n    case 2:\n      operation === \"push\" ? finalNumber.push(` ${SUFFIXES.THOUSAND} `) : finalNumber.unshift(` ${SUFFIXES.THOUSAND} `);\n      break;\n\n    case 3:\n      operation === \"push\" ? finalNumber.push(` ${SUFFIXES.MILLION} `) : finalNumber.unshift(` ${SUFFIXES.MILLION} `);\n      break;\n\n    case 4:\n      operation === \"push\" ? finalNumber.push(` ${SUFFIXES.BILLION} `) : finalNumber.unshift(` ${SUFFIXES.BILLION} `);\n      break;\n\n    case 5:\n      operation === \"push\" ? finalNumber.push(` ${SUFFIXES.TRILLION} `) : finalNumber.unshift(` ${SUFFIXES.TRILLION} `);\n      break;\n\n    default:\n      noop();\n  }\n\n  return finalNumber;\n}\n\nfunction addFirstSuffix(arrays, finalNumber) {\n  if (arrays.prefixArray.length === 1) {\n    addSuffix(arrays.array, finalNumber, \"unshift\");\n    finalNumber.unshift(NUMBERS_STRINGS[arrays.prefixArray[0]]);\n  }\n\n  return finalNumber;\n}\n\nfunction addSuffixPerBlock(index, blocks, finalNumber) {\n  if (index !== blocks.blocksOfHundreds.length - 1) {\n    addSuffix(blocks.blocksOfHundreds, finalNumber, \"push\");\n    blocks.blocksOfHundredsCopy.pop();\n  }\n\n  return {\n    blocks,\n    finalNumber\n  };\n}\n\nfunction addConnective(index, blocksOfHundreds, finalNumber) {\n  if (index === blocksOfHundreds.length - 1) {\n    finalNumber.push(\" and \");\n  }\n}\n\nfunction normalize(stringifiedNumber, finalNumber) {\n  let stringifiedNumberArray = Array.from(stringifiedNumber);\n  let stringifiedNumberArraySlice = stringifiedNumberArray.slice(0, stringifiedNumber.length % 3);\n  stringifiedNumberArray.splice(0, stringifiedNumberArraySlice.length);\n  stringifiedNumberArray = divide(stringifiedNumberArray.join(\"\"), finalNumber);\n  addFirstSuffix({\n    prefixArray: stringifiedNumberArraySlice,\n    array: stringifiedNumberArray\n  }, finalNumber);\n  return finalNumber;\n}\n\nexport default function useConvert(number) {\n  if (number) {\n    if (NUMBERS_STRINGS.hasOwnProperty(number)) {\n      return NUMBERS_STRINGS[number];\n    }\n\n    const stringifiedNumber = number.toString();\n    let finalNumber = [];\n\n    if (stringifiedNumber.length % 3 === 0) {\n      divide(stringifiedNumber, finalNumber);\n    } else {\n      //TODO: IMPLEMENT CONVERTING FOR NON 3 MULTIPLE STRINGS\n      normalize(stringifiedNumber, finalNumber);\n    }\n\n    return finalNumber;\n  }\n}","map":{"version":3,"sources":["/home/victor/Documents/React/assessment/js-numerals/src/hooks/useConvert.js"],"names":["NUMBERS_STRINGS","SUFFIXES","noop","pushItem","array","item","push","divide","stringifiedNumber","finalNumber","blocksOfHundreds","match","blocksOfHundredsCopy","index","block","entries","parseInt","HUNDRED","convert","addSuffixPerBlock","addConnective","dicker","hasOwnProperty","dickerPrefix","addSuffix","stringArray","operation","length","THOUSAND","unshift","MILLION","BILLION","TRILLION","addFirstSuffix","arrays","prefixArray","blocks","pop","normalize","stringifiedNumberArray","Array","from","stringifiedNumberArraySlice","slice","splice","join","useConvert","number","toString"],"mappings":"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","sourcesContent":["import { NUMBERS_STRINGS, SUFFIXES } from \"../constants\";\n\nconst noop = () => {};\n\nconst pushItem = (array, item) => array.push(item);\n\nfunction divide(stringifiedNumber, finalNumber) {\n  const blocksOfHundreds = stringifiedNumber.match(/.{1,3}/g);\n  const blocksOfHundredsCopy = [...blocksOfHundreds];\n\n  for (const [index, block] of blocksOfHundreds.entries()) {\n    finalNumber.push(NUMBERS_STRINGS[parseInt(block[0])] + \" \");\n    finalNumber.push(SUFFIXES.HUNDRED + \" \");\n\n    convert(block, finalNumber, \"push\");\n    addSuffixPerBlock(\n      index,\n      { blocksOfHundreds, blocksOfHundredsCopy },\n      finalNumber\n    );\n    addConnective(index, blocksOfHundreds, finalNumber);\n  }\n\n  return finalNumber;\n}\n\nfunction convert(block, finalNumber) {\n  if (parseInt(block[1]) !== 0) {\n    const dicker = block[1] + block[2];\n    if (NUMBERS_STRINGS.hasOwnProperty(parseInt(dicker))) {\n      return pushItem(finalNumber, NUMBERS_STRINGS[parseInt(dicker)]);\n    } else {\n      const dickerPrefix = block[1] + \"0\";\n      return pushItem(\n        finalNumber,\n        `${NUMBERS_STRINGS[dickerPrefix]} ${\n          NUMBERS_STRINGS[parseInt(block[2])]\n        }`\n      );\n    }\n  }\n}\n\nfunction addSuffix(stringArray, finalNumber, operation) {\n  switch (stringArray.length) {\n    case 2:\n      operation === \"push\"\n        ? finalNumber.push(` ${SUFFIXES.THOUSAND} `)\n        : finalNumber.unshift(` ${SUFFIXES.THOUSAND} `);\n      break;\n    case 3:\n      operation === \"push\"\n        ? finalNumber.push(` ${SUFFIXES.MILLION} `)\n        : finalNumber.unshift(` ${SUFFIXES.MILLION} `);\n      break;\n    case 4:\n      operation === \"push\"\n        ? finalNumber.push(` ${SUFFIXES.BILLION} `)\n        : finalNumber.unshift(` ${SUFFIXES.BILLION} `);\n      break;\n    case 5:\n      operation === \"push\"\n        ? finalNumber.push(` ${SUFFIXES.TRILLION} `)\n        : finalNumber.unshift(` ${SUFFIXES.TRILLION} `);\n      break;\n    default:\n      noop();\n  }\n\n  return finalNumber;\n}\n\nfunction addFirstSuffix(arrays, finalNumber) {\n  if (arrays.prefixArray.length === 1) {\n    addSuffix(arrays.array, finalNumber, \"unshift\");\n    finalNumber.unshift(NUMBERS_STRINGS[arrays.prefixArray[0]]);\n  }\n\n  return finalNumber;\n}\n\nfunction addSuffixPerBlock(index, blocks, finalNumber) {\n  if (index !== blocks.blocksOfHundreds.length - 1) {\n    addSuffix(blocks.blocksOfHundreds, finalNumber, \"push\");\n    blocks.blocksOfHundredsCopy.pop();\n  }\n\n  return { blocks, finalNumber };\n}\n\nfunction addConnective(index, blocksOfHundreds, finalNumber) {\n  if (index === blocksOfHundreds.length - 1) {\n    finalNumber.push(\" and \");\n  }\n}\n\nfunction normalize(stringifiedNumber, finalNumber) {\n  let stringifiedNumberArray = Array.from(stringifiedNumber);\n  let stringifiedNumberArraySlice = stringifiedNumberArray.slice(\n    0,\n    stringifiedNumber.length % 3\n  );\n\n  stringifiedNumberArray.splice(0, stringifiedNumberArraySlice.length);\n  stringifiedNumberArray = divide(stringifiedNumberArray.join(\"\"), finalNumber);\n  addFirstSuffix(\n    { prefixArray: stringifiedNumberArraySlice, array: stringifiedNumberArray },\n    finalNumber\n  );\n\n  return finalNumber;\n}\n\nexport default function useConvert(number) {\n  if (number) {\n    if (NUMBERS_STRINGS.hasOwnProperty(number)) {\n      return NUMBERS_STRINGS[number];\n    }\n\n    const stringifiedNumber = number.toString();\n    let finalNumber = [];\n\n    if (stringifiedNumber.length % 3 === 0) {\n      divide(stringifiedNumber, finalNumber);\n    } else {\n      //TODO: IMPLEMENT CONVERTING FOR NON 3 MULTIPLE STRINGS\n      normalize(stringifiedNumber, finalNumber);\n    }\n\n    return finalNumber;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}