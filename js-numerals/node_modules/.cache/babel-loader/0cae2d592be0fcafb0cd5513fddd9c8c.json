{"ast":null,"code":"import { NUMBERS_STRINGS, SUFFIXES } from \"../constants\";\n\nconst noop = () => {};\n\nconst pushItem = (array, item) => array.push(item);\n\nconst unshiftItem = (array, item) => array.unshift(item);\n\nfunction divide(stringifiedNumber, finalNumber) {\n  const blocksOfHundreds = stringifiedNumber.match(/.{1,3}/g);\n  const blocksOfHundredsCopy = [...blocksOfHundreds];\n\n  for (const [index, block] of blocksOfHundreds.entries()) {\n    finalNumber.push(NUMBERS_STRINGS[parseInt(block[0])] + \" \");\n    finalNumber.push(SUFFIXES.HUNDRED + \" \");\n    convert(block, finalNumber, \"push\");\n    addSuffixPerBlock(index, {\n      blocksOfHundreds,\n      blocksOfHundredsCopy\n    }, finalNumber);\n  }\n\n  return finalNumber;\n}\n\nfunction convert(block, finalNumber, operation) {\n  if (parseInt(block[1]) !== 0) {\n    const dicker = block[1] + block[2];\n\n    if (NUMBERS_STRINGS.hasOwnProperty(parseInt(dicker))) {\n      return operation === \"push\" ? pushItem(finalNumber, NUMBERS_STRINGS[parseInt(dicker)]) : unshiftItem(finalNumber, NUMBERS_STRINGS[parseInt(dicker)]);\n    } else {\n      const dickerPrefix = block[1] + \"0\";\n      return operation === \"push\" ? pushItem(finalNumber, `${NUMBERS_STRINGS[dickerPrefix]} ${NUMBERS_STRINGS[parseInt(block[2])]}`) : unshiftItem(finalNumber, `${NUMBERS_STRINGS[dickerPrefix]} ${NUMBERS_STRINGS[parseInt(block[2])]}`);\n    }\n  }\n}\n\nfunction addSuffix(stringArray, finalNumber) {\n  switch (stringArray.length) {\n    case 2:\n      finalNumber.push(` ${SUFFIXES.THOUSAND} `);\n      break;\n\n    case 3:\n      finalNumber.push(` ${SUFFIXES.MILLION} `);\n      break;\n\n    case 4:\n      finalNumber.push(` ${SUFFIXES.BILLION} `);\n      break;\n\n    case 5:\n      finalNumber.push(` ${SUFFIXES.TRILLION} `);\n      break;\n\n    default:\n      noop();\n  }\n\n  return finalNumber;\n}\n\nfunction addSuffixPerBlock(index, blocks, finalNumber) {\n  if (index !== blocks.blocksOfHundreds.length - 1) {\n    addSuffix(blocks.blocksOfHundreds, finalNumber);\n    blocks.blocksOfHundredsCopy.pop();\n    return {\n      blocks,\n      finalNumber\n    };\n  }\n}\n\nfunction normalize(stringifiedNumber, finalNumber) {\n  let stringifiedNumberArray = Array.from(stringifiedNumber);\n  let stringifiedNumberArraySlice = stringifiedNumberArray.slice(0, stringifiedNumber.length % 3);\n  stringifiedNumberArray.splice(0, stringifiedNumberArraySlice.length);\n  stringifiedNumberArray = divide(stringifiedNumberArray.join(\"\"), finalNumber);\n  convert(stringifiedNumberArraySlice, finalNumber, \"unshift\");\n  return finalNumber;\n}\n\nexport default function useConvert(number) {\n  if (number) {\n    if (NUMBERS_STRINGS.hasOwnProperty(number)) {\n      return NUMBERS_STRINGS[number];\n    }\n\n    const stringifiedNumber = number.toString();\n    let finalNumber = [];\n\n    if (stringifiedNumber.length % 3 === 0) {\n      divide(stringifiedNumber, finalNumber);\n    } else {\n      //TODO: IMPLEMENT CONVERTING FOR NON 3 MULTIPLE STRINGS\n      normalize(stringifiedNumber, finalNumber);\n    }\n\n    return finalNumber;\n  }\n}","map":{"version":3,"sources":["/home/victor/Documents/React/assessment/js-numerals/src/hooks/useConvert.js"],"names":["NUMBERS_STRINGS","SUFFIXES","noop","pushItem","array","item","push","unshiftItem","unshift","divide","stringifiedNumber","finalNumber","blocksOfHundreds","match","blocksOfHundredsCopy","index","block","entries","parseInt","HUNDRED","convert","addSuffixPerBlock","operation","dicker","hasOwnProperty","dickerPrefix","addSuffix","stringArray","length","THOUSAND","MILLION","BILLION","TRILLION","blocks","pop","normalize","stringifiedNumberArray","Array","from","stringifiedNumberArraySlice","slice","splice","join","useConvert","number","toString"],"mappings":"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","sourcesContent":["import { NUMBERS_STRINGS, SUFFIXES } from \"../constants\";\n\nconst noop = () => {};\n\nconst pushItem = (array, item) => array.push(item);\n\nconst unshiftItem = (array, item) => array.unshift(item);\n\nfunction divide(stringifiedNumber, finalNumber) {\n  const blocksOfHundreds = stringifiedNumber.match(/.{1,3}/g);\n  const blocksOfHundredsCopy = [...blocksOfHundreds];\n\n  for (const [index, block] of blocksOfHundreds.entries()) {\n    finalNumber.push(NUMBERS_STRINGS[parseInt(block[0])] + \" \");\n    finalNumber.push(SUFFIXES.HUNDRED + \" \");\n\n    convert(block, finalNumber, \"push\");\n    addSuffixPerBlock(\n      index,\n      { blocksOfHundreds, blocksOfHundredsCopy },\n      finalNumber\n    );\n  }\n\n  return finalNumber;\n}\n\nfunction convert(block, finalNumber, operation) {\n  if (parseInt(block[1]) !== 0) {\n    const dicker = block[1] + block[2];\n    if (NUMBERS_STRINGS.hasOwnProperty(parseInt(dicker))) {\n      return operation === \"push\"\n        ? pushItem(finalNumber, NUMBERS_STRINGS[parseInt(dicker)])\n        : unshiftItem(finalNumber, NUMBERS_STRINGS[parseInt(dicker)]);\n    } else {\n      const dickerPrefix = block[1] + \"0\";\n      return operation === \"push\"\n        ? pushItem(\n            finalNumber,\n            `${NUMBERS_STRINGS[dickerPrefix]} ${\n              NUMBERS_STRINGS[parseInt(block[2])]\n            }`\n          )\n        : unshiftItem(\n            finalNumber,\n            `${NUMBERS_STRINGS[dickerPrefix]} ${\n              NUMBERS_STRINGS[parseInt(block[2])]\n            }`\n          );\n    }\n  }\n}\n\nfunction addSuffix(stringArray, finalNumber) {\n  switch (stringArray.length) {\n    case 2:\n      finalNumber.push(` ${SUFFIXES.THOUSAND} `);\n      break;\n    case 3:\n      finalNumber.push(` ${SUFFIXES.MILLION} `);\n      break;\n    case 4:\n      finalNumber.push(` ${SUFFIXES.BILLION} `);\n      break;\n    case 5:\n      finalNumber.push(` ${SUFFIXES.TRILLION} `);\n      break;\n    default:\n      noop();\n  }\n\n  return finalNumber;\n}\n\nfunction addSuffixPerBlock(index, blocks, finalNumber) {\n  if (index !== blocks.blocksOfHundreds.length - 1) {\n    addSuffix(blocks.blocksOfHundreds, finalNumber);\n    blocks.blocksOfHundredsCopy.pop();\n\n    return { blocks, finalNumber };\n  }\n}\n\nfunction normalize(stringifiedNumber, finalNumber) {\n  let stringifiedNumberArray = Array.from(stringifiedNumber);\n  let stringifiedNumberArraySlice = stringifiedNumberArray.slice(\n    0,\n    stringifiedNumber.length % 3\n  );\n\n  stringifiedNumberArray.splice(0, stringifiedNumberArraySlice.length);\n  stringifiedNumberArray = divide(stringifiedNumberArray.join(\"\"), finalNumber);\n  convert(stringifiedNumberArraySlice, finalNumber, \"unshift\");\n\n  return finalNumber;\n}\n\nexport default function useConvert(number) {\n  if (number) {\n    if (NUMBERS_STRINGS.hasOwnProperty(number)) {\n      return NUMBERS_STRINGS[number];\n    }\n\n    const stringifiedNumber = number.toString();\n    let finalNumber = [];\n\n    if (stringifiedNumber.length % 3 === 0) {\n      divide(stringifiedNumber, finalNumber);\n    } else {\n      //TODO: IMPLEMENT CONVERTING FOR NON 3 MULTIPLE STRINGS\n      normalize(stringifiedNumber, finalNumber);\n    }\n\n    return finalNumber;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}