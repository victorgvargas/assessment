{"ast":null,"code":"import { NUMBERS_STRINGS, SUFFIXES } from \"../constants\";\nexport default function useConvert(number) {\n  if (number) {\n    if (NUMBERS_STRINGS.hasOwnProperty(number)) {\n      return NUMBERS_STRINGS[number];\n    }\n\n    const stringifiedNumber = number.toString();\n    const finalNumber = [];\n\n    if (stringifiedNumber.length % 3 === 0) {\n      const blocksOfHundreds = stringifiedNumber.match(/.{1,3}/g);\n\n      for (const block of blocksOfHundreds) {\n        finalNumber.push(NUMBERS_STRINGS[parseInt(block[0])] + \" \");\n        finalNumber.push(SUFFIXES.THOUSAND + \" \");\n\n        if (parseInt(block[1]) !== 0) {\n          const dicker = block[1] + block[2];\n          const hasProperty = NUMBERS_STRINGS.hasOwnProperty(parseInt(dicker));\n          NUMBERS_STRINGS.hasOwnProperty(parseInt(dicker)) ? finalNumber.push(NUMBERS_STRINGS[parseInt(dicker)]) : finalNumber.push(NUMBERS_STRINGS[parseInt(NUMBERS_STRINGS[block[1]] + NUMBERS_STRINGS[block[2]])]);\n        }\n      }\n    }\n\n    return finalNumber;\n  }\n}","map":{"version":3,"sources":["/home/victor/Documents/React/assessment/js-numerals/src/hooks/useConvert.js"],"names":["NUMBERS_STRINGS","SUFFIXES","useConvert","number","hasOwnProperty","stringifiedNumber","toString","finalNumber","length","blocksOfHundreds","match","block","push","parseInt","THOUSAND","dicker","hasProperty"],"mappings":"AAAA,SAASA,eAAT,EAA0BC,QAA1B,QAA0C,cAA1C;AAEA,eAAe,SAASC,UAAT,CAAoBC,MAApB,EAA4B;AACzC,MAAIA,MAAJ,EAAY;AACV,QAAIH,eAAe,CAACI,cAAhB,CAA+BD,MAA/B,CAAJ,EAA4C;AAC1C,aAAOH,eAAe,CAACG,MAAD,CAAtB;AACD;;AAED,UAAME,iBAAiB,GAAGF,MAAM,CAACG,QAAP,EAA1B;AACA,UAAMC,WAAW,GAAG,EAApB;;AAEA,QAAIF,iBAAiB,CAACG,MAAlB,GAA2B,CAA3B,KAAiC,CAArC,EAAwC;AACtC,YAAMC,gBAAgB,GAAGJ,iBAAiB,CAACK,KAAlB,CAAwB,SAAxB,CAAzB;;AACA,WAAK,MAAMC,KAAX,IAAoBF,gBAApB,EAAsC;AACpCF,QAAAA,WAAW,CAACK,IAAZ,CAAiBZ,eAAe,CAACa,QAAQ,CAACF,KAAK,CAAC,CAAD,CAAN,CAAT,CAAf,GAAsC,GAAvD;AACAJ,QAAAA,WAAW,CAACK,IAAZ,CAAiBX,QAAQ,CAACa,QAAT,GAAoB,GAArC;;AACA,YAAID,QAAQ,CAACF,KAAK,CAAC,CAAD,CAAN,CAAR,KAAuB,CAA3B,EAA8B;AAC5B,gBAAMI,MAAM,GAAGJ,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA/B;AACA,gBAAMK,WAAW,GAAGhB,eAAe,CAACI,cAAhB,CAA+BS,QAAQ,CAACE,MAAD,CAAvC,CAApB;AACAf,UAAAA,eAAe,CAACI,cAAhB,CAA+BS,QAAQ,CAACE,MAAD,CAAvC,IACIR,WAAW,CAACK,IAAZ,CAAiBZ,eAAe,CAACa,QAAQ,CAACE,MAAD,CAAT,CAAhC,CADJ,GAEIR,WAAW,CAACK,IAAZ,CACEZ,eAAe,CACba,QAAQ,CACNb,eAAe,CAACW,KAAK,CAAC,CAAD,CAAN,CAAf,GAA4BX,eAAe,CAACW,KAAK,CAAC,CAAD,CAAN,CADrC,CADK,CADjB,CAFJ;AASD;AACF;AACF;;AAED,WAAOJ,WAAP;AACD;AACF","sourcesContent":["import { NUMBERS_STRINGS, SUFFIXES } from \"../constants\";\n\nexport default function useConvert(number) {\n  if (number) {\n    if (NUMBERS_STRINGS.hasOwnProperty(number)) {\n      return NUMBERS_STRINGS[number];\n    }\n\n    const stringifiedNumber = number.toString();\n    const finalNumber = [];\n\n    if (stringifiedNumber.length % 3 === 0) {\n      const blocksOfHundreds = stringifiedNumber.match(/.{1,3}/g);\n      for (const block of blocksOfHundreds) {\n        finalNumber.push(NUMBERS_STRINGS[parseInt(block[0])] + \" \");\n        finalNumber.push(SUFFIXES.THOUSAND + \" \");\n        if (parseInt(block[1]) !== 0) {\n          const dicker = block[1] + block[2];\n          const hasProperty = NUMBERS_STRINGS.hasOwnProperty(parseInt(dicker));\n          NUMBERS_STRINGS.hasOwnProperty(parseInt(dicker))\n            ? finalNumber.push(NUMBERS_STRINGS[parseInt(dicker)])\n            : finalNumber.push(\n                NUMBERS_STRINGS[\n                  parseInt(\n                    NUMBERS_STRINGS[block[1]] + NUMBERS_STRINGS[block[2]]\n                  )\n                ]\n              );\n        }\n      }\n    }\n\n    return finalNumber;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}