{"ast":null,"code":"import { NUMBERS_STRINGS, SUFFIXES } from \"../constants\";\n\nconst noop = () => {};\n\nfunction divide(stringifiedNumber, finalNumber) {\n  const blocksOfHundreds = stringifiedNumber.match(/.{1,3}/g);\n  const blocksOfHundredsCopy = [...blocksOfHundreds];\n\n  for (const [index, block] of blocksOfHundreds.entries()) {\n    finalNumber.push(NUMBERS_STRINGS[parseInt(block[0])] + \" \");\n    finalNumber.push(SUFFIXES.HUNDRED + \" \");\n    convert(block, finalNumber);\n    addSuffix(index, {\n      blocksOfHundreds,\n      blocksOfHundredsCopy\n    }, finalNumber);\n  }\n\n  return finalNumber;\n}\n\nfunction convert(block, finalNumber) {\n  if (parseInt(block[1]) !== 0) {\n    const dicker = block[1] + block[2];\n\n    if (NUMBERS_STRINGS.hasOwnProperty(parseInt(dicker))) {\n      return finalNumber.push(NUMBERS_STRINGS[parseInt(dicker)]);\n    } else {\n      const dickerPrefix = block[1] + \"0\";\n      return finalNumber.push(`${NUMBERS_STRINGS[dickerPrefix]} ${NUMBERS_STRINGS[parseInt(block[2])]}`);\n    }\n  }\n}\n\nfunction addSuffix(index, blocks, finalNumber) {\n  if (index !== blocks.blocksOfHundreds.length - 1) {\n    switch (blocks.blocksOfHundredsCopy.length) {\n      case 2:\n        finalNumber.push(` ${SUFFIXES.THOUSAND} `);\n        break;\n\n      case 3:\n        finalNumber.push(` ${SUFFIXES.MILLION} `);\n        break;\n\n      case 4:\n        finalNumber.push(` ${SUFFIXES.BILLION} `);\n        break;\n\n      case 5:\n        finalNumber.push(` ${SUFFIXES.TRILLION} `);\n        break;\n\n      default:\n        noop();\n    }\n\n    blocks.blocksOfHundredsCopy.pop();\n    return {\n      blocks,\n      finalNumber\n    };\n  }\n}\n\nexport default function useConvert(number) {\n  if (number) {\n    if (NUMBERS_STRINGS.hasOwnProperty(number)) {\n      return NUMBERS_STRINGS[number];\n    }\n\n    const stringifiedNumber = number.toString();\n    let finalNumber = [];\n\n    if (stringifiedNumber.length % 3 === 0) {\n      divide(stringifiedNumber, finalNumber);\n    } else {\n      const stringifiedNumberArray = Array(stringifiedNumber);\n      let stringifiedNumberArraySlice = stringifiedNumberArray.slice(0, stringifiedNumber.length - stringifiedNumber.length % 3);\n      stringifiedNumberArray.splice(0, stringifiedNumberArraySlice);\n      stringifiedNumberArraySlice = divide(stringifiedNumberArraySlice.join(\"\"), finalNumber);\n    }\n\n    return finalNumber;\n  }\n}","map":{"version":3,"sources":["/home/victor/Documents/React/assessment/js-numerals/src/hooks/useConvert.js"],"names":["NUMBERS_STRINGS","SUFFIXES","noop","divide","stringifiedNumber","finalNumber","blocksOfHundreds","match","blocksOfHundredsCopy","index","block","entries","push","parseInt","HUNDRED","convert","addSuffix","dicker","hasOwnProperty","dickerPrefix","blocks","length","THOUSAND","MILLION","BILLION","TRILLION","pop","useConvert","number","toString","stringifiedNumberArray","Array","stringifiedNumberArraySlice","slice","splice","join"],"mappings":"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","sourcesContent":["import { NUMBERS_STRINGS, SUFFIXES } from \"../constants\";\n\nconst noop = () => {};\n\nfunction divide(stringifiedNumber, finalNumber) {\n  const blocksOfHundreds = stringifiedNumber.match(/.{1,3}/g);\n  const blocksOfHundredsCopy = [...blocksOfHundreds];\n\n  for (const [index, block] of blocksOfHundreds.entries()) {\n    finalNumber.push(NUMBERS_STRINGS[parseInt(block[0])] + \" \");\n    finalNumber.push(SUFFIXES.HUNDRED + \" \");\n\n    convert(block, finalNumber);\n    addSuffix(index, { blocksOfHundreds, blocksOfHundredsCopy }, finalNumber);\n  }\n\n  return finalNumber;\n}\n\nfunction convert(block, finalNumber) {\n  if (parseInt(block[1]) !== 0) {\n    const dicker = block[1] + block[2];\n    if (NUMBERS_STRINGS.hasOwnProperty(parseInt(dicker))) {\n      return finalNumber.push(NUMBERS_STRINGS[parseInt(dicker)]);\n    } else {\n      const dickerPrefix = block[1] + \"0\";\n      return finalNumber.push(\n        `${NUMBERS_STRINGS[dickerPrefix]} ${\n          NUMBERS_STRINGS[parseInt(block[2])]\n        }`\n      );\n    }\n  }\n}\n\nfunction addSuffix(index, blocks, finalNumber) {\n  if (index !== blocks.blocksOfHundreds.length - 1) {\n    switch (blocks.blocksOfHundredsCopy.length) {\n      case 2:\n        finalNumber.push(` ${SUFFIXES.THOUSAND} `);\n        break;\n      case 3:\n        finalNumber.push(` ${SUFFIXES.MILLION} `);\n        break;\n      case 4:\n        finalNumber.push(` ${SUFFIXES.BILLION} `);\n        break;\n      case 5:\n        finalNumber.push(` ${SUFFIXES.TRILLION} `);\n        break;\n      default:\n        noop();\n    }\n    blocks.blocksOfHundredsCopy.pop();\n\n    return { blocks, finalNumber };\n  }\n}\n\nexport default function useConvert(number) {\n  if (number) {\n    if (NUMBERS_STRINGS.hasOwnProperty(number)) {\n      return NUMBERS_STRINGS[number];\n    }\n\n    const stringifiedNumber = number.toString();\n    let finalNumber = [];\n\n    if (stringifiedNumber.length % 3 === 0) {\n      divide(stringifiedNumber, finalNumber);\n    } else {\n      const stringifiedNumberArray = Array(stringifiedNumber);\n      let stringifiedNumberArraySlice = stringifiedNumberArray.slice(\n        0,\n        stringifiedNumber.length - (stringifiedNumber.length % 3)\n      );\n\n      stringifiedNumberArray.splice(0, stringifiedNumberArraySlice);\n      stringifiedNumberArraySlice = divide(\n        stringifiedNumberArraySlice.join(\"\"),\n        finalNumber\n      );\n    }\n\n    return finalNumber;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}